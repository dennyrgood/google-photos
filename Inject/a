def _extract_and_add_names(self, avoid_scroll=True):
        """Extract names from webpage section and add to description if not already there.
        
        Args:
            avoid_scroll: If True, skip clicking/positioning to avoid scrolling the right panel
        """
        try:
            print('[NAMES] Extracting names from webpage...')
            
            # Load names and special cases from names.json
            import json
            import os # Needed for better error message on file not found
            # NOTE: This assumes 'names.json' is accessible in the working directory
            with open('names.json') as f:
                data = json.load(f)
                names_list = data.get('names', [])
                special_cases = data.get('special_cases', {})
            
            print(f'[NAMES] Loaded special cases: {special_cases}')
            
            # Extract clean names (without parentheses) for logging
            clean_names = []
            for name_entry in names_list:
                clean = ''.join(c for c in name_entry if c not in '()').strip()
                if clean and clean != '4':
                    clean_names.append(clean)
            
            print(f'[NAMES] Searching for names: {clean_names}')
            
            # JS logic to extract all candidates (focusing ONLY on span.Y8X4Pc)
            js_find_names = """() => {
                let foundNames = [];

                // 1. Find the active sidebar root to scope the search
                const textarea = document.querySelector('textarea');
                if (!textarea) return null;

                // Traverse up to find the closest ancestor with class 'ZPTMcc' (the main details panel)
                let sidebarRoot = textarea.closest('.ZPTMcc');

                // Fallback, in case ZPTMcc structure changes
                if (!sidebarRoot) {
                    sidebarRoot = textarea.closest('.YW656b');
                }

                if (!sidebarRoot) {
                    console.error('[NAMES] Could not find active sidebar root. Aborting name extraction.');
                    return null;
                }

                // *** REMOVED SEARCH FOR div.DgVY7 (Album Names) ***
                // We are ONLY focusing on the cleaner People/Place Tags (span.Y8X4Pc).
                
                // 2. Contextual Names (People/Place Tags) - Search ONLY within the sidebarRoot
                const allSpanNames = sidebarRoot.querySelectorAll('span.Y8X4Pc');
                // The script looks at the last 5 elements
                const spansToCheck = Array.from(allSpanNames).slice(-5);
                for (const span of spansToCheck) {
                    // Check for visibility (offsetHeight > 0)
                    if (span.offsetHeight > 0 && span.textContent) {
                        foundNames.push(span.textContent.trim());
                    }
                }
                
                // Return null if nothing is found, matching the original Python check
                return foundNames.length > 0 ? foundNames : null;
            }"""
            
            found_names = self.page.evaluate(js_find_names)
            
            if not found_names:
                print('[NAMES] No name sections found on webpage')
                return
            
            print(f'[NAMES] Found names in webpage: {found_names}')
            
            # Retrieve the current description (assuming _sample_description exists)
            current_desc = self._sample_description() 
            if not current_desc:
                current_desc = ''
            
            # Normalize description early for comparison
            desc_normalized = ' '.join(current_desc.split()).lower()

            print(f'[NAMES] Current description: {repr(current_desc)[:80]}')
            
            if not avoid_scroll:
                # Assuming _position_cursor_at_end exists
                print('[NAMES] Positioning cursor at END before adding names')
                self._position_cursor_at_end()
            else:
                print('[NAMES] Skipping cursor positioning to avoid scroll')
                
            for found_name in found_names:
                print(f'[NAMES] Processing: {repr(found_name)}')
                
                # Normalize spaces
                name_to_check = ' '.join(found_name.split())
                
                # 1. Year/Digit Prefix Check
                if name_to_check and name_to_check[0:4].isdigit():
                    print(f'[NAMES] Skipping year-prefixed text: "{name_to_check}"')
                    continue

                if name_to_check and name_to_check.startswith("0"):
                    print(f'[NAMES] Skipping name starting with 0: "{name_to_check}"')
                    continue
                
                # 2. Special Case Mapping
                if name_to_check in special_cases:
                    mapped_name = special_cases[name_to_check]
                    print(f'[NAMES] Special case: "{name_to_check}" -> "{mapped_name}"')
                    found_name = mapped_name
                else:
                    found_name = name_to_check # Use the cleaned version
                    
                # 3. Duplication Check
                # Use the mapped name (or cleaned original) for duplication check
                if found_name.lower() in desc_normalized: 
                    print(f'[NAMES] "{found_name}" already in description, skipping')
                    continue
                
                # 4. Append to description
                if not avoid_scroll:
                    # Assuming _position_cursor_at_end exists
                    self._position_cursor_at_end()
                    
                print(f'[NAMES] Adding " {found_name}" to description')
                # Assuming append_text exists
                self.append_text(' ' + found_name + ' ')
                
                # Update normalized description for subsequent duplication checks in this loop
                current_desc += ' ' + found_name + ' '
                desc_normalized = ' '.join(current_desc.split()).lower()
                
            if not avoid_scroll:
                # Assuming _position_cursor_at_end exists
                print('[NAMES] Positioning cursor at END after adding all names')
                self._position_cursor_at_end()
                
        except FileNotFoundError as e:
            # Catch the specific error for names.json not found
            print(f'[NAMES] ERROR: Could not find or load names.json. Check working directory. ({e})')
        except Exception as e:
            print(f'[NAMES] ERROR: {e}')
